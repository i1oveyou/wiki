<!doctype html>
<html >
<head>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!--[if lt IE 9]>
                <script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
        <![endif]-->
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />

    <!-- <link rel="stylesheet" type="text/css" href="template.css" /> -->
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/template.css" />

    <link href="https://vjs.zencdn.net/5.4.4/video-js.css" rel="stylesheet" />

    <script src="https://code.jquery.com/jquery-2.2.1.min.js"></script>
    <!-- <script type='text/javascript' src='menu/js/jquery.cookie.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.hoverIntent.minified.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.dcjqaccordion.2.7.min.js'></script> -->

    <!-- <link href="menu/css/skins/blue.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/graphite.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/grey.css" rel="stylesheet" type="text/css" /> -->
  
    <!-- <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
        
  
    <!-- <script src="script.js"></script> -->
  
    <!-- <script src="jquery.sticky-kit.js "></script> -->
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.cookie.js'></script>
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.hoverIntent.minified.js'></script>
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.dcjqaccordion.2.7.min.js'></script>

    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/blue.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/graphite.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/grey.css" rel="stylesheet" type="text/css" />
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
    <script src="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/script.js"></script>
  
    <script src="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/jquery.sticky-kit.js"></script>
    <meta name="generator" content="pandoc" />
  <title>wiki-crypto-常见算法-sm4</title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>

    
    <div class="navbar navbar-static-top">
    <div class="navbar-inner">
      <div class="container">
        <span class="doc-title">wiki-crypto-常见算法-sm4</span>
        <ul class="nav pull-right doc-info">
                            </ul>
      </div>
    </div>
  </div>
    <div class="container">
    <div class="row">
            <div id="TOC" class="span3">
        <div class="well toc">

        <ul>
        <li><a href="#sm4" id="toc-sm4">SM4</a></li>
        <li><a href="#密钥生成算法"
        id="toc-密钥生成算法">密钥生成算法</a></li>
        <li><a href="#加密算法流程"
        id="toc-加密算法流程">加密算法流程</a></li>
        <li><a href="#解密算法流程"
        id="toc-解密算法流程">解密算法流程</a></li>
        <li><a href="#查表优化" id="toc-查表优化">查表优化</a></li>
        </ul>

        </div>
      </div>
            <div class="span9">

      
      <h1 id="sm4">SM4</h1>
<h1 id="密钥生成算法">密钥生成算法</h1>
<p>小总一下:</p>
<p>没有密钥的SM4算法,依然可以体现SM4的神奇之处</p>
<p>只不过是异或罢了</p>
<p>所以后面遇到SM4,没有密钥,也不要惊讶</p>
<p>密钥16字节,额外生成32个dword</p>
<p>比如<code>BYTE key[] = "Key[QkC5mKNFnzR]";</code></p>
<p>我先列出整体的一个加密流程</p>
<pre><code>DWORD* keyGen(DWORD* Key)
{
    int j = 0, i = 0;
    DWORD* keyArr32 = 0;
    DWORD trol[] = { 0,13,23 };
    DWORD tmp123;
    keyArr32 = malloc(36 * 4);
    /***************************开始生成子秘钥********************************************/
    for (i = 0; i &lt; 4; i++)
    {
        endianSwapt(&amp;Key[i]);
        keyArr32[i] = Key[i] ^ TBL_SYS_PARAMS[i];
    }

    for (i = 0; i &lt; 32; i++)//32次循环迭代运算
    {
        //5-36为32个子秘钥
        tmp123 = keyArr32[i + 1] ^ keyArr32[i + 2] ^ keyArr32[i + 3] ^ TBL_FIX_PARAMS[i];
        keyArr32[i + 4] = keyArr32[i + 0] ^ F(tmp123,trol,3);
    }
    return keyArr32;
}</code></pre>
<p>首先,我们传入的<code>DWORD Key[4]</code>做一个端序转化</p>
<p>也就是对每个dword做一个端序的转化</p>
<p>然后我们每次会连续取出前面4个dword来生成第5个dword</p>
<p>先取出keyArr32[i + 1] , keyArr32[i + 2] ,keyArr32[i + 3]
,和一个常量异或</p>
<p><code>tmp123 = keyArr32[i + 1] ^ keyArr32[i + 2] ^ keyArr32[i + 3] ^ TBL_FIX_PARAMS[i];</code></p>
<p>然后把tmp123 传入一个F函数,然会返回一个dword,然后和我们的
<code>keyArr32[i + 0]</code>来个异或</p>
<p>最后生成了第5个<code>keyArr32[i + 4]</code></p>
<p>这样往复的迭代下去,会生成32个dword</p>
<p>其中描述一下F函数</p>
<p>传入的参数</p>
<p><code>tmp123</code></p>
<p><code>DWORD trol[] = { 0,13,23 };</code></p>
<p><code>3</code></p>
<p>其中F函数长这个样子</p>
<pre><code>DWORD F(DWORD tmp123,DWORD* tRol,int rolLen)
{
    int i = 0;
    BYTE* lpA = &amp;tmp123;
    DWORD dwRet = 0;
    //endianSwapt(lpA);
    for (i = 0; i &lt; 4; i++)
    {
        lpA[i] = TBL_SBOX[lpA[i]];
    }
    //endianSwapt(lpA);
    for (i = 0; i &lt; rolLen; i++)
    {
        dwRet ^= fROL(tmp123, tRol[i]);
    }
    return dwRet;
}</code></pre>
<p>做一个类似于AES/DES的查表操作</p>
<p>最后来一个循环左移动,分别循环左移0,13,23位,每次移位都来个异或操作</p>
<p>然后这就是循环位移的操作</p>
<h1 id="加密算法流程">加密算法流程</h1>
<p>小结:</p>
<p>加密和解密都涉及一些端序的转化</p>
<p>其实端序转化不是什么阻碍.反正是对称的,</p>
<p>也就是说加密有端序转化,那么解密也要有.</p>
<p>值得注意的是加密生成的arr[3+32]</p>
<p>arr[-1],,arr[-2],arr[-3],,arr[-4]才是最后的加密结果</p>
<p>在解密的时候,也是拿着arr[-1],,arr[-2],arr[-3],,arr[-4]去解密</p>
<p>而不是arr[-4],,arr[-3],arr[-2],,arr[-1]</p>
<p>首先,加密算法采用的和解密算法是一样的流程</p>
<p>加密算法采用的和解密算法只不过传入的参数不一样</p>
<p>同时他们 和密钥生成算法其实很相似</p>
<p>加密算法每次分组加密16字节</p>
<p>整体流程如下,</p>
<pre><code>void SM4(int round, DWORD* KeyArr36, BYTE* input, int mod)
{
    int j,i;
    DWORD  dwArr36[36] = { 0 };
    DWORD* dw_input = input;
    DWORD tmp123;
    DWORD trol[] = { 0,2,10,18,24 };
    for (i = 0; i &lt; round; i++)
    {
        dw_input = input + 16 * i;
        for (j = 0; j &lt; 4; j++)
        {
            endianSwapt(&amp;dw_input[j]);//端序转化
            dwArr36[j] = dw_input[j];//赋值
            //printf(&quot;%08X\n&quot;, dwArr36[j]);
        }
        //加密
        for (j = 0; j &lt; 32; j++)//根据已经有的DWORD[4],去生成32个新的DWORD[4]
        {

            tmp123 = dwArr36[j + 1] ^ dwArr36[j + 2] ^ dwArr36[j + 3] ^ KeyArr36[j*mod];
            dwArr36[j + 4] = dwArr36[j + 0] ^ F(tmp123, trol, 5);
            //printf(&quot;%08X\n&quot;, dwArr36[j + 4]);
        }
        for (j = 0; j &lt; 4; j++)
        {
            endianSwapt(&amp;dwArr36[35 - j]);//端序转化
            dw_input[j] = dwArr36[35 - j];//逆序赋值
        }
    }
    return;
}</code></pre>
<p>我们对加密算法传入的参数是</p>
<p><code>SM4(round, &amp;keyArr[4], new_input, 1);</code></p>
<p>总之注意我们的传入的<code>&amp;keyArr[4]</code></p>
<p>然后说一下加密的流程</p>
<p>提前准备了一个<code>DWORD  dwArr36[36] = { 0 };</code></p>
<p>然后把已有传入的 <code>dw_input[0,4)</code>做一个端序转化</p>
<p>然后赋值给<code>dwArr36[0,4)</code></p>
<p>然后就是一个和密钥算法差不多的操作了,加密算法只是没有异或一些常量</p>
<p>经过不断的迭代后,最后的dword [4] 差不多就是加密结果</p>
<p>对最后的dword [4]既要反正取出,还得做一个端序转化</p>
<h1 id="解密算法流程">解密算法流程</h1>
<p>先说一下解密算法和加密算法有什么不同</p>
<p>首先 采用的算法是一致</p>
<p>传递的参数不同</p>
<p>加密是: <code>SM4(round, &amp;keyArr[4], new_input, 1);</code></p>
<p>解密是: <code>SM4(round, &amp;keyArr[35], new_input, -1);</code></p>
<p>于是导致的现象就是在迭代算法那里出现了差异</p>
<pre><code>//加密
for (j = 0; j &lt; 32; j++)//根据已经有的DWORD[4],去生成32个新的DWORD[4]
{

    tmp123 = dwArr36[j + 1] ^ dwArr36[j + 2] ^ dwArr36[j + 3] ^ KeyArr36[j*mod];
    dwArr36[j + 4] = dwArr36[j + 0] ^ F(tmp123, trol, 5);
    //printf(&quot;%08X\n&quot;, dwArr36[j + 4]);
}</code></pre>
<p>加密异或的是<code>KeyArr36[4],KeyArr36[5],...,KeyArr36[35],</code></p>
<p>解密异或的是<code>KeyArr36[35],KeyArr36[34],...,KeyArr36[4],</code></p>
<p>然后解密的原理是什么呢??? 虽然看上去很对称</p>
<pre><code>666C6167
7B4B306B
61736E63
4D344D7D
4DFB7570
...
662A41F3
2B40A6A5
2B7479D0
E08C3D9A
4DF32282</code></pre>
<pre><code>4DF32282
E08C3D9A
2B7479D0
2B40A6A5
662A41F3
...
4DFB7570
4D344D7D
61736E63
7B4B306B
666C6167</code></pre>
<p>可以看出,每次解密都是反向的求出上一位数据是什么,最后求出了我们的明文输入</p>
<p>就像是</p>
<p>x0,x1,x2,x3 –&gt;x4</p>
<p>x4,x3,x2,x1 –&gt;x0</p>
<p>首先对于<code>x0,x1,x2,x3 --&gt;x4</code>正常不过了</p>
<p>但是<code>x4,x3,x2,x1 --&gt;x0</code>是什么原理呢???</p>
<p>假如我么只有轮循环1次</p>
<p>加密数据是(A,B,C,D)然后生成了E</p>
<p><code>E=F(B^C^D^key,xx,xx)^A=E</code></p>
<p>我么把<code>F(B^C^D^key,xx,xx)=M</code></p>
<p>于是E=M^A</p>
<p>所以如何解密? 当然是A=M^E</p>
<p>其中<code>M=F(B^C^D^key,xx,xx)</code></p>
<p>且B<sup>C</sup>D^key,xx,xx参数都是已知的</p>
<p>所以就很好解密啦</p>
<p>然后轮循环次数不是32的话,仔细琢磨一下就知道了</p>
<p>所以,我们就知道了,其实F函数的具体内容并不重要</p>
<p>无论F函数多么的复杂,只要保证y=f(x)是一个一对一的关系即可</p>
<h1 id="查表优化">查表优化</h1>
<p>参考链接:</p>
<p><a
href="https://www.cnblogs.com/kentle/p/15510582.html">https://www.cnblogs.com/kentle/p/15510582.html</a></p>
            </div>
    </div>
  </div>
  <script src="https://vjs.zencdn.net/5.4.4/video.js"></script>

</body>
</html>
