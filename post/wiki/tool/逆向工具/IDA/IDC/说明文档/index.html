<!doctype html>
<html >
<head>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!--[if lt IE 9]>
                <script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
        <![endif]-->
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />

    <!-- <link rel="stylesheet" type="text/css" href="template.css" /> -->
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/template.css" />

    <link href="https://vjs.zencdn.net/5.4.4/video-js.css" rel="stylesheet" />

    <script src="https://code.jquery.com/jquery-2.2.1.min.js"></script>
    <!-- <script type='text/javascript' src='menu/js/jquery.cookie.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.hoverIntent.minified.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.dcjqaccordion.2.7.min.js'></script> -->

    <!-- <link href="menu/css/skins/blue.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/graphite.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/grey.css" rel="stylesheet" type="text/css" /> -->
  
    <!-- <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
        
  
    <!-- <script src="script.js"></script> -->
  
    <!-- <script src="jquery.sticky-kit.js "></script> -->
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.cookie.js'></script>
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.hoverIntent.minified.js'></script>
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.dcjqaccordion.2.7.min.js'></script>

    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/blue.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/graphite.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/grey.css" rel="stylesheet" type="text/css" />
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
    <script src="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/script.js"></script>
  
    <script src="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/jquery.sticky-kit.js"></script>
    <meta name="generator" content="pandoc" />
  <title>IDA脚本编写-IDC说明文档</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>

    
    <div class="navbar navbar-static-top">
    <div class="navbar-inner">
      <div class="container">
        <span class="doc-title">IDA脚本编写-IDC说明文档</span>
        <ul class="nav pull-right doc-info">
                            </ul>
      </div>
    </div>
  </div>
    <div class="container">
    <div class="row">
            <div id="TOC" class="span3">
        <div class="well toc">

        <ul>
        <li><a href="#说明文档" id="toc-说明文档">说明文档</a></li>
        <li><a href="#参考链接" id="toc-参考链接">参考链接</a></li>
        <li><a href="#数据类型" id="toc-数据类型">数据类型</a></li>
        <li><a href="#字符串操作"
        id="toc-字符串操作">字符串操作</a></li>
        <li><a href="#数组" id="toc-数组">数组</a></li>
        <li><a href="#运算符" id="toc-运算符">运算符</a></li>
        <li><a href="#函数定义" id="toc-函数定义">函数定义</a></li>
        <li><a href="#宏定义" id="toc-宏定义">宏定义</a></li>
        <li><a href="#api-手册" id="toc-api-手册">API 手册</a></li>
        <li><a href="#数据读取修改"
        id="toc-数据读取修改">数据读取修改</a>
        <ul>
        <li><a href="#patchbyteworddword"
        id="toc-patchbyteworddword">PatchByte/Word/Dword</a></li>
        <li><a href="#byteworddwordqword"
        id="toc-byteworddwordqword">Byte/Word/Dword/Qword</a></li>
        <li><a href="#isloaded" id="toc-isloaded">isLoaded</a></li>
        </ul></li>
        <li><a href="#用户交互函数"
        id="toc-用户交互函数">用户交互函数</a>
        <ul>
        <li><a href="#message" id="toc-message">Message</a></li>
        <li><a href="#print" id="toc-print">print</a></li>
        <li><a href="#warning" id="toc-warning">warning</a></li>
        <li><a href="#askstr" id="toc-askstr">AskStr</a></li>
        <li><a href="#askfile" id="toc-askfile">AskFile</a></li>
        <li><a href="#askyn" id="toc-askyn">AskYN</a></li>
        <li><a href="#screenea" id="toc-screenea">ScreenEA</a></li>
        <li><a href="#jump" id="toc-jump">Jump</a></li>
        </ul></li>
        <li><a href="#字符串操作函数"
        id="toc-字符串操作函数">字符串操作函数</a>
        <ul>
        <li><a href="#form" id="toc-form">form</a></li>
        <li><a href="#sprintf" id="toc-sprintf">sprintf</a></li>
        <li><a href="#atol" id="toc-atol">atol</a></li>
        <li><a href="#xtol" id="toc-xtol">xtol</a></li>
        <li><a href="#ltoa" id="toc-ltoa">ltoa</a></li>
        <li><a href="#ord" id="toc-ord">ord</a></li>
        <li><a href="#strlen" id="toc-strlen">strlen</a></li>
        <li><a href="#strstr" id="toc-strstr">strstr</a></li>
        <li><a href="#substr" id="toc-substr">substr</a></li>
        </ul></li>
        <li><a href="#文件操作" id="toc-文件操作">文件操作</a>
        <ul>
        <li><a href="#fopen" id="toc-fopen">fopen</a></li>
        <li><a href="#fclose" id="toc-fclose">fclose</a></li>
        <li><a href="#filelength"
        id="toc-filelength">filelength</a></li>
        <li><a href="#fgetc" id="toc-fgetc">fgetc</a></li>
        <li><a href="#fputc" id="toc-fputc">fputc</a></li>
        <li><a href="#fprintf" id="toc-fprintf">fprintf</a></li>
        <li><a href="#writestr" id="toc-writestr">writestr</a></li>
        <li><a href="#readstr" id="toc-readstr">readstr</a></li>
        <li><a href="#writelong" id="toc-writelong">writelong</a></li>
        <li><a href="#readlong" id="toc-readlong">readlong</a></li>
        <li><a href="#writeshort"
        id="toc-writeshort">writeshort</a></li>
        <li><a href="#readshort" id="toc-readshort">readshort</a></li>
        <li><a href="#loadfile" id="toc-loadfile">loadfile</a></li>
        <li><a href="#savefile" id="toc-savefile">savefile</a></li>
        </ul></li>
        <li><a href="#操作数据库名称"
        id="toc-操作数据库名称">操作数据库名称</a>
        <ul>
        <li><a href="#name" id="toc-name">Name</a></li>
        <li><a href="#nameex" id="toc-nameex">NameEx</a></li>
        <li><a href="#makenameex"
        id="toc-makenameex">MakeNameEx</a></li>
        <li><a href="#locbyname" id="toc-locbyname">LocByName</a></li>
        <li><a href="#locbynameex"
        id="toc-locbynameex">LocByNameEx</a></li>
        </ul></li>
        <li><a href="#操作数据库的函数"
        id="toc-操作数据库的函数">操作数据库的函数</a>
        <ul>
        <li><a href="#makeunkn" id="toc-makeunkn">MakeUnkn</a></li>
        <li><a href="#makecode" id="toc-makecode">MakeCode</a></li>
        <li><a href="#makebyte" id="toc-makebyte">MakeByte</a></li>
        <li><a href="#makecomm" id="toc-makecomm">MakeComm</a></li>
        <li><a href="#makefunction"
        id="toc-makefunction">MakeFunction</a></li>
        <li><a href="#makestr" id="toc-makestr">MakeStr</a></li>
        </ul></li>
        <li><a href="#数据库搜索函数"
        id="toc-数据库搜索函数">数据库搜索函数</a>
        <ul>
        <li><a href="#findcode" id="toc-findcode">FindCode</a></li>
        <li><a href="#finddata" id="toc-finddata">FindData</a></li>
        <li><a href="#findbinary"
        id="toc-findbinary">FindBinary</a></li>
        <li><a href="#findtext" id="toc-findtext">FindText</a></li>
        </ul></li>
        <li><a href="#操作函数" id="toc-操作函数">操作函数</a>
        <ul>
        <li><a href="#getfunctionattr"
        id="toc-getfunctionattr">GetFunctionAttr</a></li>
        <li><a href="#getfunctionname"
        id="toc-getfunctionname">GetFunctionName</a></li>
        <li><a href="#nextfunction"
        id="toc-nextfunction">NextFunction</a></li>
        <li><a href="#prevfunction"
        id="toc-prevfunction">PrevFunction</a></li>
        </ul></li>
        <li><a href="#代码交叉引用函数"
        id="toc-代码交叉引用函数">代码交叉引用函数</a>
        <ul>
        <li><a href="#rfirst" id="toc-rfirst">Rfirst</a></li>
        <li><a href="#rnext" id="toc-rnext">Rnext</a></li>
        <li><a href="#xreftype" id="toc-xreftype">XrefType</a></li>
        <li><a href="#rfirstb" id="toc-rfirstb">RfirstB</a></li>
        <li><a href="#rnextb" id="toc-rnextb">RnextB</a></li>
        </ul></li>
        <li><a href="#数据交叉引用"
        id="toc-数据交叉引用">数据交叉引用</a>
        <ul>
        <li><a href="#dfirst" id="toc-dfirst">Dfirst</a></li>
        <li><a href="#dnext" id="toc-dnext">Dnext</a></li>
        <li><a href="#xreftype-1"
        id="toc-xreftype-1">XrefType()</a></li>
        <li><a href="#dfirstb" id="toc-dfirstb">DfirstB</a></li>
        <li><a href="#dnextb" id="toc-dnextb">DnextB</a></li>
        </ul></li>
        <li><a href="#反汇编提取" id="toc-反汇编提取">反汇编提取</a>
        <ul>
        <li><a href="#getdisasm" id="toc-getdisasm">GetDisasm</a></li>
        <li><a href="#getmnem" id="toc-getmnem">GetMnem</a></li>
        <li><a href="#getopnd" id="toc-getopnd">GetOpnd</a></li>
        <li><a href="#getoptype" id="toc-getoptype">GetOpType</a></li>
        <li><a href="#getoperandvalue"
        id="toc-getoperandvalue">GetOperandValue</a></li>
        <li><a href="#itemsize" id="toc-itemsize">ItemSize</a></li>
        <li><a href="#getregvaluerip"
        id="toc-getregvaluerip">GetRegValue(“RIP”)</a></li>
        <li><a href="#get_func_name"
        id="toc-get_func_name">get_func_name</a></li>
        </ul></li>
        <li><a href="#misc-func" id="toc-misc-func">misc-func</a></li>
        <li><a href="#附录" id="toc-附录">附录</a></li>
        </ul>

        </div>
      </div>
            <div class="span9">

      
      <h1 id="说明文档">说明文档</h1>
<p>学习链接:</p>
<p>[https://blog.csdn.net/weixin_44531336/article/details/125076279](</p>
<h1 id="参考链接">参考链接</h1>
<p>🧡参考链接: lyshark <a
href="https://www.cnblogs.com/LyShark/p/13100048.html">https://www.cnblogs.com/LyShark/p/13100048.html</a></p>
<p><a
href="https://introspelliam.github.io/2017/09/18/tools/IDA%E7%9A%84%E8%B0%83%E8%AF%95%E8%84%9A%E6%9C%ACidc/">https://introspelliam.github.io/2017/09/18/tools/IDA%E7%9A%84%E8%B0%83%E8%AF%95%E8%84%9A%E6%9C%ACidc/</a></p>
<p>在IDA中按下【shift + F2】可调出脚本编辑器</p>
<p>就IDApython的话,感觉比价火</p>
<p>但是,我喜欢C,IDC的参考指令可以说,巨少</p>
<p><a
href="https://www.hex-rays.com/products/ida/support/idadoc/">https://www.hex-rays.com/products/ida/support/idadoc/</a></p>
<h1 id="数据类型">数据类型</h1>
<p>他们的数值比较都是有符号的,且一般为4字节比较(猜测的)</p>
<p>无符号比较需要去除符号位,比如&amp;0xff的Byte</p>
<p>x86的IDC,,,0xffffffff==-1,但是0xffffffffffffffff≠-1</p>
<p>IDC中所有变量都被定义成auto类型，会自动进行类型转换，一般类型有整数型、字符串类型、浮点型</p>
<p>变量在没有赋予初始值的情况下,为0</p>
<ul>
<li>局部变量：auto counter;</li>
<li>extern 引入全局变量的声明，extern outsideGlobal;</li>
<li>字符串支持加好连接：auto str = “hello” + “world”;</li>
<li>字符串支持分片操作：str1 = str[7:9];</li>
<li>没有strcat…等等函数</li>
</ul>
<pre><code>auto addr, reg, val;    //没有初始化声明的多个变量
auto count = 0;         //已声明和初始化</code></pre>
<pre><code>extern outsideGlobal;

static main()
{
    extern insideGlobal;
    outsideGlobal = &quot;Global&quot;;
    insideGlobal = 1;
}</code></pre>
<p>虽然IDC没有数组数据类型,但你可以使用分片运算符来处理IDC字符串,</p>
<p>就好像他们是数组一样,IDC分片的用法：</p>
<pre><code>auto str = &quot;String to slice&quot;;
auto s1, s2, s3, s4;
s1 = str[7:9];          //&#39;to&#39;
s2 = str[ :6];         //&#39;String&#39;
s3 = str[10: ];        //&#39;slice&#39;
s4 = str[5];               //&#39;g&#39;</code></pre>
<h1 id="字符串操作">字符串操作</h1>
<pre><code>if ( op == &quot;jmp&quot; || op == &quot;call&quot; )
{
...
}</code></pre>
<pre><code>#include &lt;idc.idc&gt;

static main()
{
    // 格式化字符串,类似于sprintf
    auto name = form(&quot;hello %s&quot;,&quot;lyshark&quot;);
    Message(&quot;格式化后的内容: %s \n&quot;,name);

    Message(&quot;十六进制转为整数: %d \n&quot;,xtol(&quot;0x41&quot;));
    Message(&quot;十进制100转为八进制: %d \n&quot;,ltoa(100,8));
    Message(&quot;十进制100转换二进制: %d \n&quot;,ltoa(100,2));
    Message(&quot;字符A的ASCII: %d \n&quot;,ord(&quot;A&quot;));
    Message(&quot;计算字符串长度: %d \n&quot;,strlen(&quot;hello lyshark&quot;));

    // 在著字符串中寻找子串
    auto main = &quot;hello lyshark&quot;;
    auto sub = &quot;lyshark&quot;;
    Message(&quot;寻找子串: %d \n&quot;,strstr(main,sub));
}</code></pre>
<h1 id="数组">数组</h1>
<p>一个例子就可以搞懂</p>
<pre><code>#include &lt;idc.idc&gt;

static main()
{
    // 创建数组元素
    auto ObjArr = CreateArray(&quot;array&quot;);
    // 获取数组指针
    auto lp_Arr = GetArrayId(&quot;array&quot;);

    Message(&quot;Arr: %X\n&quot;, lp_Arr);

    // 设置两个字符串变量
    SetArrayString(lp_Arr, 0, &quot;hello&quot;);
    SetArrayString(lp_Arr, 1, &quot;re4mile&quot;);

    // 设置两个整数变量
    SetArrayLong(lp_Arr, 2, 100);
    SetArrayLong(lp_Arr, 3, 200);

    // 如果提取字符串使用 AR_STR 标记 ，提取整数使用 AR_LONG
    auto sz1 = GetArrayElement(AR_STR, lp_Arr, 0);
    auto sz2 = GetArrayElement(AR_STR, lp_Arr, 1);
    Message(&quot;字符串: %s %s !\n&quot;, sz1, sz2);

    auto num1 = GetArrayElement(AR_LONG, lp_Arr, 2);
    auto num2 = GetArrayElement(AR_LONG, lp_Arr, 3);
    Message(&quot;整数: %d %d\n&quot;, num1,num2);

    // 删除数组的0号元素
    DelArrayElement(AR_STR, lp_Arr, 0);
    // 注销整个数组
    DeleteArray(lp_Arr);
}</code></pre>
<h1 id="运算符">运算符</h1>
<p>许多标准的C语言操作符（+、-、*、/、%、&lt;&lt;、&gt;&gt;、++、–）包括三元运算符（?:)</p>
<p>在IDC同样适用，但复合赋值运算符+=不支持、逗号操作符也不被支持。</p>
<p>IDC几乎支持C中的所有运算和逻辑操作符，但是所有整数操作数均作为有符号的值处理。</p>
<p>这会影响到整数比较与右移位运算。如果需要进行逻辑右移位运算，你必须修改结果的最高位，自己移位，</p>
<p>如下代码：</p>
<p>result = ( x &gt;&gt; 1 ) &amp; 0x7fffffff; //将最大有效位设置为0</p>
<p>与C语言一样，IDC所有简单语句均以分号结束。</p>
<p>Switch语句是IDC唯一不支持的C风格复合语句。</p>
<p>在使用for语句时IDC不支持复合赋值运算符，如果你希望以除1以外的其他值为单位进行计数，就需要注意这一点，</p>
<p>如下代码：</p>
<pre><code>auto i;
for (i = 0; i &lt; 10; i += 2)
{

}       //不合法，不支持 +=
for (i = 0; i &lt; 10; i = i + 2)
{

}    //合法</code></pre>
<h1 id="函数定义">函数定义</h1>
<p>定义一个函数</p>
<pre><code>#include &lt; idc&gt;

// 定义一个函数
static OutPutAddress(My)
{
    auto tmp;
    tmp = 0x1300 + My;
    return tmp;
}

static main()
{
    auto ret = OutPutAddress(0x14);
    Message(&quot;%x \n&quot;,ret);
}</code></pre>
<h1 id="宏定义">宏定义</h1>
<p>BADADDR = -1</p>
<h1 id="api-手册">API 手册</h1>
<p><a
href="https://www.hex-rays.com/products/ida/support/idadoc/162.shtml">https://www.hex-rays.com/products/ida/support/idadoc/162.shtml</a></p>
<p>其实就是</p>
<figure>
<img
src="%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3%2000f0fc98b7e949fbbbc0a3f932629dde/Untitled.png"
alt="Untitled" />
<figcaption aria-hidden="true">Untitled</figcaption>
</figure>
<p>jmp 到当前位置+1</p>
<pre><code>EB FF           jmp     short near ptr loc_1144+1
-------------------------------------------------------------
                dw 0BFC0h
                dq 0FFFEDFE800000068h, 65BFC0FFEBFFh, 0FFEBFFFFFED2E800h
                dq 0C5E80000006CBFC0h, 6CBFC0FFEBFFFFFEh, 0FFFFFEB8E8000000h
                dq 6FBFC0FFEBh, 0C0FFEBFFFFFEABE8h, 0FE9EE800000020BFh
                dq 77BFC0FFEBFFFFh, 0EBFFFFFE91E80000h, 0E80000006FBFC0FFh</code></pre>
<p>他的特征代码是EB FF</p>
<p>EB是jmp FF是偏移</p>
<p>于是这种没有意义的跳转应该给nop掉</p>
<pre><code>EB                                      db 0EBh
;---------------------------------------------------------------------------
FF C0                                   inc     eax
BF 68 00 00 00                          mov     edi, 68h ; &#39;h&#39;
E8 DF FE FF FF                          call    _putchar</code></pre>
<p>如果程序中有大量的这种花指令.那么你不可能手动的一个一个去nop掉</p>
<p>用脚本</p>
<pre><code>#include &lt; idc&gt;
static main()
{
    auto x, target_str, ProcRange;
    target_str = &quot;EB FF C0 BF&quot;;
    for (x = FindBinary(MinEA(), 0x03, target_str); x != BADADDR; x = FindBinary(x, 0x03, target_str))
    {
        PatchByte(x, 0x90);
    }
}</code></pre>
<p>FindBinary(MinEA(), 0x03, target_str)的意思是?</p>
<p>从地址MinEA()处按0x03的模式遍历字节码target_str</p>
<p>MinEA()是最小的地址</p>
<p>PatchByte(x, 0x90);是把x指向的第一个字节给nop掉</p>
<h1 id="数据读取修改">数据读取修改</h1>
<h3 id="patchbyteworddword">PatchByte/Word/Dword</h3>
<p>void PatchByte(long addr , long val)</p>
<p>设置虚拟地址addr处的一个字节值，</p>
<p>PatchByte可更换为</p>
<p>PatchWord，PatchDword</p>
<p>设置虚拟地址addr处的2字节和4字节值。</p>
<h3 id="byteworddwordqword">Byte/Word/Dword/Qword</h3>
<p>long Byte( long addr)，从虚拟地址 addr处读取一个字节值。</p>
<p>long word(long addr)，从虚拟地址addr处读取一个字（2字节）值。</p>
<p>1ong Dword(long addr)，从虚拟地址addr处读取一个双字（4字节)值。</p>
<h3 id="isloaded">isLoaded</h3>
<p>boo1 isLoaded(long
addr)，如果addr包含有效数据，则返回1，否则返回0。</p>
<p>5）long atol（string val），将10进制val转化成对应整数值。</p>
<p>6）long xtol（string val），将16进制val转化成对应整数值。</p>
<p>7）long ord（string ch），返回单字符字符串ch的ASCII值。</p>
<p>8）string Name（long
addr），返回与给定地址有关的名称，如果该位置没有名称，则返回空字符串。</p>
<h1 id="用户交互函数">用户交互函数</h1>
<h3 id="message">Message</h3>
<p>void Message(string format….)，</p>
<p>在输出窗口打印一条格式化消息。这个函数类似于C语言的printf函数，并接受printf风格的格式化字符串。</p>
<h3 id="print">print</h3>
<p>void print( . ..)，</p>
<p>在输出窗口中打印每个参数的字符串表示形式。</p>
<h3 id="warning">warning</h3>
<p>void warning(string format. …)，</p>
<p>在对话框中显示一条格式化消息。</p>
<h3 id="askstr">AskStr</h3>
<p>string AskStr(string default, string prompt)，</p>
<p>显示一个输入框，要求用户输入一个字符串值。</p>
<p>如果操作成功，则返回用户的字符串;</p>
<p>如果对话框被取消，则返回0。</p>
<h3 id="askfile">AskFile</h3>
<p>string AskFile(1ong doSave，string mask,string prompt)，</p>
<p>显示一个文件选择对话框，以简化选择文件的任务。</p>
<p>你可以创建新文件保存数据( doSave=1)，或选择现有的文件读取数据（
doSave=0)。</p>
<p>你可以根据mask （如* .<em>或</em>. idc)过滤显示的文件列表。</p>
<p>如果操作成功，则返回选定文件的名称;</p>
<p>如果对话框被取消,则返回O。</p>
<h3 id="askyn">AskYN</h3>
<p>long AskYN( long default, string prompt)，</p>
<p>用一个答案为“是”或“否”的问题提示用户，</p>
<p>突出一个默认的答案(1为是，0为否，-1为取消)。</p>
<p>返回值是一个表示选定答案的整数。</p>
<h3 id="screenea">ScreenEA</h3>
<p>long ScreenEA(),</p>
<p>返回当前光标所在位置的虚拟地址</p>
<pre><code>#include &lt; idc&gt;

static main()
{
    auto CurrAddress = ScreenEA();
    //ScreenEA() 返回当前光标所在的虚拟地址
     Message(&quot;程序OEP =&gt; 0x%x \n&quot;,CurrAddress);
}</code></pre>
<h3 id="jump">Jump</h3>
<p>boo1 Jump( 1ong addr)，跳转到反汇编窗口的指定地址。</p>
<p>因为IDC没有任何调试工具，你可能需要将Message
函数作为你的主要调试工具。</p>
<p>其他几个AskXXX函数用于处理更加专用的输人，如整数输人。请参考帮助系统文档了解可用的
AskXXX函数的完整列表。</p>
<p>如果希望创建一个根据光标位置调整其行为的脚本，这时，ScreenEA函数就非常有用，因为你可以通过它确定光标的当前位置。</p>
<p>同样，如果你的脚本需要将用户的注意力转移到反汇编代码清单中的某个位置，也需要用到Jump函数。</p>
<h1 id="字符串操作函数">字符串操作函数</h1>
<h3 id="form">form</h3>
<p>string form(string format，…)</p>
<p>//preIDA5.6，返回一个新字符串，该字符串根据所提供的格式化字符串和值进行格式化。这个函数基本上等同于C语言的sprintf函数</p>
<h3 id="sprintf">sprintf</h3>
<p>string sprintf(string format . . . .)</p>
<p>//IDA5.6+，在 IDA5.6中，sprintf用于替代form(参见上面)。</p>
<h3 id="atol">atol</h3>
<p>1ong ato1(string va1)，将十进制值va1转换成对应的整数值。</p>
<h3 id="xtol">xtol</h3>
<p>1ong xtol(string
val)，将十六进制值val(可选择以0x开头）转换成对应的整数值。</p>
<p>Message(“十六进制转为整数: %d ”,xtol(“0x41”))</p>
<h3 id="ltoa">ltoa</h3>
<p>string ltoa(1ong va1，1ong radix)，</p>
<p>以指定的radix (2、8、10或16)返回va1的字符串值。</p>
<p>Message(“十进制100转为八进制: %d ”,ltoa(100,8));</p>
<h3 id="ord">ord</h3>
<p>long ord(string ch)，返回单字符字符串ch 的ASCI值。</p>
<p>Message(“字符A的ASCII: %d ”,ord(“A”));</p>
<h3 id="strlen">strlen</h3>
<p>long strlen(string str)，返回所提供字符串的长度。</p>
<p>Message(“计算字符串长度: %d ”,strlen(“hello re4mile”));</p>
<h3 id="strstr">strstr</h3>
<p>long strstr(string str. string substr)，</p>
<p>返回str中 substr 的索引。</p>
<p>如果没有发现子字符串，则返回-1。</p>
<p>类似于python的语法 if “dqx” in “I am dqx”</p>
<pre><code>if(strstr(op,&quot;push    esi&quot;)==0)
{
    ...
    }
其实他就是一个strcmp的作用,如果返回0,说明字符串刚好匹配</code></pre>
<h3 id="substr">substr</h3>
<p>string substr(string str. long start.1ong end)，</p>
<p>返回包含 str 中由start到end-1位置的字符的子字符串。</p>
<p>如果使用分片（IDA5.6及更高版本)，此函数等同于str[start:end]。如前所述，IDC中没有任何字符数据类型，它也不支持任何数组语法。</p>
<p>如果你想要遍历字符串的每个字符，必须把字符串中的每个字符当成连续的单字符子字符串处理。</p>
<h1 id="文件操作">文件操作</h1>
<p>输出窗口并不总是显示脚本输出的理想位置</p>
<p>对于生成大量文本或二进制数据的脚本，你可能希望将其结果输出到磁盘文件上。</p>
<p>我们已经讨论了如何使用AskFi1e函数要求用户输入文件名。</p>
<p>但是，AskFi1e仅返回一个包含文件名的字符串值。</p>
<p>IDC的文件处理函数如下所示。</p>
<h3 id="fopen">fopen</h3>
<p>long fopen(string filename，string mode)</p>
<p>返回一个整数文件句柄（如果发生错误，则返回0)</p>
<p>供所有IDC文件输入/输出函数使用</p>
<p>mode参数与C语言的fopen 函数使用的模式(
r表示读取，w表示写入，等等）类似</p>
<h3 id="fclose">fclose</h3>
<p>void fclose(long hand1e)</p>
<p>关闭fopen中文件句柄指定的文件。</p>
<h3 id="filelength">filelength</h3>
<p>long filelength(long handle)</p>
<p>返回指定文件的长度，</p>
<p>如果发生错误，则返回-1。</p>
<h3 id="fgetc">fgetc</h3>
<p>1ong fgetc(long handle)，从给定文件中读取一个字节</p>
<p>如果发生错误，则返回-1。</p>
<h3 id="fputc">fputc</h3>
<p>long fputc(long val. long handle)，写入一个字节到给定文件中</p>
<p>如果操作成功，则返回0;</p>
<p>如果发生错误，则返回-1。</p>
<h3 id="fprintf">fprintf</h3>
<p>long fprintf(1ong handle, string format，…)</p>
<p>将一个格式化字符串写入到给定文件中。</p>
<h3 id="writestr">writestr</h3>
<p>long writestr(long handle. string
str)，将指定的字符串写入到给定文件中。</p>
<h3 id="readstr">readstr</h3>
<p>string/long readstr(1ong handle)，从给定文件中读取一个字符串</p>
<p>这个函数读取到下一个换行符为止的所有字符（包括非ASCII字符)，包括换行符本身(ASCII
OxA )。</p>
<p>如果操作成功，则返回字符串;</p>
<p>如果读取到文件结尾，则返回-1。</p>
<h3 id="writelong">writelong</h3>
<p>long writelong(long handle. long va1， long bigendian)</p>
<p>使用大端(bigendian-1)或小端(
bigendian=0)字节顺序将一个4字节整数写入到给定文件。</p>
<h3 id="readlong">readlong</h3>
<p>long readlong( long handle,long bigendian)</p>
<p>使用大端(bigendian=1)</p>
<p>或小端( bigendian=-Q)字节顺序从给定的文件中读取一个4字节整数。</p>
<h3 id="writeshort">writeshort</h3>
<p>long writeshort(long handle，long va1,long bigendian)</p>
<p>使用大端( bigendian=1)或小端(
bigendian=0)字节顺序将一个2字节整数写入到给定的文件。</p>
<h3 id="readshort">readshort</h3>
<p>long readshort( 1ong handle,long bigendian)</p>
<p>使用大端(bigendian-1)或小端(
bigendian=0)字节顺序从给定的文件中读取一个2字节整数。</p>
<h3 id="loadfile">loadfile</h3>
<p>bool loadfile(long handle ,long pos，long addr. long length)</p>
<p>从给定文件的pos位置读取length数量的字节，并将这些字节写入到以addr地址开头的数据库中。</p>
<h3 id="savefile">savefile</h3>
<p>bool savefile(long handle，1ong pos., long addr. long length)</p>
<p>将以addr数据库地址开头的length数量的字节写入给定文件的pos位置。</p>
<p>eg</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;idc.idc&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> getFuncName<span class="op">(</span>ea<span class="op">)</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> funcName <span class="op">=</span> get_func_name<span class="op">(</span>ea<span class="op">);</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> dm <span class="op">=</span> demangle_name<span class="op">(</span>funcName<span class="op">,</span> get_inf_attr<span class="op">(</span>INF_LONG_DN<span class="op">));</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>dm <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        funcName <span class="op">=</span> dm<span class="op">;</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> funcName<span class="op">;</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> functionDump<span class="op">(</span>ip_CurFuncStart<span class="op">)</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> funcName <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ip_CurFuncEnd <span class="op">=</span> <span class="bn">0x0</span><span class="op">;</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ip_NextFuncStart<span class="op">;</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> sz_FileName <span class="op">=</span> get_idb_path<span class="op">()[</span><span class="dv">0</span><span class="op">:-</span><span class="dv">4</span><span class="op">]</span> <span class="op">+</span> <span class="st">&quot;_dump.txt&quot;</span><span class="op">;</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> fp <span class="op">=</span> fopen<span class="op">(</span>sz_FileName<span class="op">,</span> <span class="st">&quot;w&quot;</span><span class="op">);</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> appendData <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>ip_CurFuncStart <span class="op">!=</span> BADADDR<span class="op">)</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>        ip_CurFuncStart     <span class="op">=</span> NextFunction<span class="op">(</span>ip_CurFuncStart<span class="op">);</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>        ip_CurFuncEnd       <span class="op">=</span> FindFuncEnd<span class="op">(</span>ip_CurFuncStart<span class="op">);</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>        ip_NextFuncStart    <span class="op">=</span> NextFunction<span class="op">(</span>ip_CurFuncStart<span class="op">);</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>        funcName            <span class="op">=</span> getFuncName<span class="op">(</span>ip_CurFuncStart<span class="op">);</span></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>ip_NextFuncStart <span class="op">==</span> BADADDR<span class="op">)</span></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>            fprintf<span class="op">(</span>fp<span class="op">,</span> <span class="st">&quot;0x</span><span class="sc">%08X</span><span class="st"> --&gt; 0x</span><span class="sc">%08X</span><span class="st"> </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> ip_CurFuncStart<span class="op">,</span> ip_CurFuncEnd<span class="op">,</span> funcName<span class="op">);</span></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>            ip_CurFuncStart <span class="op">=</span> ip_NextFuncStart<span class="op">;</span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>        appendData <span class="op">=</span> ip_NextFuncStart <span class="op">-</span> ip_CurFuncEnd<span class="op">;</span></span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>       <span class="co">// ip_CurFuncEnd = ip_NextFuncStart - 1;//他们之间的差别不仅仅是1,因为会有字节的填充</span></span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a>        fprintf<span class="op">(</span>fp<span class="op">,</span> <span class="st">&quot;0x</span><span class="sc">%08X</span><span class="st"> --&gt; 0x</span><span class="sc">%08X</span><span class="st"> + 0x</span><span class="sc">%08X</span><span class="st"> </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> ip_CurFuncStart<span class="op">,</span> ip_CurFuncEnd<span class="op">,</span> appendData<span class="op">,</span>funcName<span class="op">);</span></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>    fclose<span class="op">(</span>fp<span class="op">);</span></span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> main<span class="op">()</span></span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a>    Message<span class="op">(</span><span class="st">&quot;Start</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a>    functionDump<span class="op">(</span><span class="bn">0x00040000</span><span class="op">);</span></span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true" tabindex="-1"></a>    Message<span class="op">(</span><span class="st">&quot;End</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="操作数据库名称">操作数据库名称</h1>
<p>在脚本中，你经常需要操纵已命名的位置。下面的IDC函数用于处理IDA数据库中已命名的位置。</p>
<h3 id="name">Name</h3>
<p>string Name(1ong addr)，</p>
<p>返回与给定地址有关的名称，</p>
<p>如果该位置没有名称，则返回空字符串。</p>
<p>如果名称被标记为局部名称，这个函数并不返回用户定义的名称。</p>
<h3 id="nameex">NameEx</h3>
<p>string NameEx(long from，long
addr)，返回与addr有关的名称。如果该位置没有名称，则返回空字符串。</p>
<p>如果
from是一个同样包含addr的函数中的地址，则这个函数返回用户定义的局部名称。</p>
<h3 id="makenameex">MakeNameEx</h3>
<p>bool MakeNameEx(1ong addr. string name. long flags)，</p>
<p>将给定的名称分配给给定的地址。该名称使用flags位掩码中指定的属性创建而成。</p>
<p>这些标志在帮助系统中的MakeNameEx文档中有记载描述，</p>
<p>可用于指定各种属性，如名称是局部名称还是公共名称、名称是否应在名称窗口中列出</p>
<h3 id="locbyname">LocByName</h3>
<p>long LocByName(string
name)，返回一个位置（名称已给定）的地址。如果数据库中没有这个名称，则返回BADADDR
( -1 )。</p>
<h3 id="locbynameex">LocByNameEx</h3>
<p>long LocByNameEx(long funcaddr， string loca
1name)，在包含funcaddr的函数中搜索给定的局部名称。如果给定的函数中没有这个名称，则返回BADADDR
( -1 )o</p>
<h1 id="操作数据库的函数">操作数据库的函数</h1>
<p>有大量函数可用于对数据库的内容进行格式化。这些函数如下所示。</p>
<h3 id="makeunkn">MakeUnkn</h3>
<p>void MakeUnkn(long addr. long flags)，</p>
<p>取消位于指定地址的项的定义。</p>
<p>这里的标志(参见IDC的MakeUnkn文档）指出是否也取消随后的项的定义</p>
<p>以及是否删除任何与取消定义的项有关的名称。</p>
<p>相关函数MakeUnknown 允许你取消大块数据的定义。</p>
<h3 id="makecode">MakeCode</h3>
<p>long MakeCode(1ong addr)，</p>
<p>将位于指定地址的字节转换成一条指令。</p>
<p>如果操作成功，则返回指令的长度，</p>
<p>否则返回0。</p>
<h3 id="makebyte">MakeByte</h3>
<p>bool MakeByte(long addr)，</p>
<p>将位于指定地址的项目转换成一个数据字节。</p>
<p>类似的函数还包括Makeword和 MakeDword。</p>
<h3 id="makecomm">MakeComm</h3>
<p>boo1 MakeComm(long addr. string comment)，</p>
<p>在给定的地址处添加一条常规注释。</p>
<h3 id="makefunction">MakeFunction</h3>
<p>bool MakeFunction(long begin，long end)，</p>
<p>将由begin到end 的指令转换成一个函数。如果end被指定为BADADDR (
-1)，IDA会尝试通过定位函数的返回指令，来自动确定该函数的结束地址。</p>
<p>开始的地址,比如说push esi</p>
<p>结束的地址,
retn那个地址不是结束,retn之外那个地址,才是,结束的地址不属于函数地址,是函数地址的边界</p>
<pre><code>#include &lt;idc.idc&gt;
static Y_MakeFunction(IP_start,IP_end)
{
    auto tmp=0;//先从开始的IP取消定义,然后再生成函数
    tmp=MakeFunction(IP_start,IP_end);
    if(tmp==1)
    {
        Message(&quot;make func ok\n&quot;);
    }
    else
    {
        Message(&quot;make func failed\n&quot;);
    }
}
static main(void)
{

    Message(&quot;work begin\n&quot;);

    Y_MakeFunction(0x0040A188,0x0040A1AA);

    Message(&quot;work done\n&quot;);
}</code></pre>
<p>运行输出</p>
<pre><code>work begin
make func ok
work done</code></pre>
<h3 id="makestr">MakeStr</h3>
<p>bool MakeStr(1ong begin，long end)，</p>
<p>创建一个当前字符串(由GetStringType返回)类型的字符串,</p>
<p>涵盖由begin到end-1之间的所有字节。</p>
<p>如果end被指定为BADADDR,IDA会尝试自动确定字符串的结束位置。</p>
<h1 id="数据库搜索函数">数据库搜索函数</h1>
<p>在IDC中，IDA的绝大部分搜索功能可通过各种FindXXX函数来实现，下面我们将介绍其中一些函数。FindXXX函数中的flags参数是一个位掩码，可用于指定查找操作的行为。3个最为常用的标志分别为SEARCH_DOWN，它指示搜索操作扫描高位地址;SEARCH_NEXT，它略过当前匹配项，以搜索下一个匹配项;SEARCH_CASE，它以区分大小写的方式进行二进制和文本搜索。</p>
<h3 id="findcode">FindCode</h3>
<p>long FindCode(long addr, long flags)，</p>
<p>从给定的地址搜索一条指令的地址</p>
<h3 id="finddata">FindData</h3>
<p>long FindData(long addr.long flags)，从给定的地址搜索一个数据项。</p>
<h3 id="findbinary">FindBinary</h3>
<p>long FindBinary(long addr，long flags，string binary)</p>
<p>从给定的地址addr搜索16进制字符串序列binary</p>
<p>返回该字节码出现的地址</p>
<pre><code>flag取值有：可选项
SEARCH_DOWN 向下搜索
SEARCH_UP 向上搜索
SEARCH_NEXT 获取下一个找到的对象。
SEARCH_CASE 指定大小写敏感度
SEARCH_UNICODE 搜索 Unicode 字符串。</code></pre>
<h3 id="findtext">FindText</h3>
<p>long FindText(long addr.long flags.1ong row.long column，string
text)，</p>
<p>在给定的地址，从给定行(
row)的给定列搜索字符串text。注意，某个给定地址的反汇编文本.可能会跨越几行，因此,你需要指定搜索应从哪一行开始。还要注意的是，SEARCH_NEXT并未定义搜索的方向，根据SEARCH_DOWN
标志，其方向可能向上也可能向下。此外，如果没有设置SEARCH_NEXT，且
addr位置的项与搜索条件匹配，则FindXXX函数很可能会返回addr参数传递给该函数的地址。</p>
<h1 id="操作函数">操作函数</h1>
<p>许多脚本专用于分析数据库中的函数。</p>
<p>IDA为经过反汇编的函数分配大量属性，如函数局部变量区域的大小、函数的参数在运行时栈上的大小。</p>
<p>下面的IDC函数可用于访问与数据库中的</p>
<h3 id="getfunctionattr">GetFunctionAttr</h3>
<p>long GetFunctionAttr(long addr, 1ong attrib)，</p>
<p>返回包含给定地址的函数的被请求的属性</p>
<p>例如，要查找一个函数的结束地址，可以使用GetFunctionAttr(addr.
FUNCATTR_END)</p>
<pre><code>funcStart = GetFunctionAttr(origEA,FUNCATTR_START);
funcEnd = GetFunctionAttr(origEA,FUNCATTR_END)</code></pre>
<h3 id="getfunctionname">GetFunctionName</h3>
<p>string GetFunctionName(long addr)</p>
<p>参数是一个指令的地址</p>
<p>返回当前指令属于哪个函数</p>
<p>如果给定的地址并不属于一个函数，则返回一个空格字符串” ”</p>
<h3 id="nextfunction">NextFunction</h3>
<p>auto NextFunction(auto addr)，</p>
<p>返回给定地址后的下一个函数的起始地址。</p>
<p>如果数据库中给定地址后没有其他函数，则返回-1。</p>
<h3 id="prevfunction">PrevFunction</h3>
<p>1ong PrevFunction(1ong addr)，</p>
<p>返回给定地址之前距离最近的函数的起始地址。</p>
<p>如果在给定地址之前没有函数，则返回-1。</p>
<p>根据函数的名称，使用LocByName函数查找该函数的起始地址。</p>
<h1 id="代码交叉引用函数">代码交叉引用函数</h1>
<h3 id="rfirst">Rfirst</h3>
<p>long Rfirst(long from)，</p>
<p>返回给定地址向其转交控制权的第–个位置。</p>
<p>如果给定的地址没有引用其他地址，则返回BADADDR ( -1 )</p>
<h3 id="rnext">Rnext</h3>
<p>long Rnext(1ong from，long current)，</p>
<p>如果current 已经在前一次调用Rfirst或Rnext时返回,</p>
<p>则返回给定地址( from )转交控制权的下一个位置。</p>
<p>如果没有其他交叉引用存在，则返回BADADDR。</p>
<h3 id="xreftype">XrefType</h3>
<p>long XrefType()，</p>
<p>返回-个常量，说明某个交叉引用查询函数（如Rfirst)</p>
<p>返回的最后一个交叉引用的类型。对于代码交叉引用，这些常量包括fl_CN(近调用)、fl_CF(远调用)、f1_JN（近跳转)、f1_JF（远跳转）和f1_F(普通顺序流)。</p>
<h3 id="rfirstb">RfirstB</h3>
<p>long RfirstB(long to)，</p>
<p>返回 转交控制权到给定地址的第一个位置。</p>
<p>如果不存在对给定地址的交叉引用，则返回BADADDR( -1 )。</p>
<h3 id="rnextb">RnextB</h3>
<p>long RnextB(1ong to. long current)，</p>
<p>如果current
已经在前一次调用RfirstB或RnextB时返回，则返回下一个转交控制权到给定地址(to)的位置。</p>
<p>如果不存在其他对给定位置的交叉引用，则返回BADADDR ( -1 ).</p>
<p>每次调用一个交叉引用函数，</p>
<p>IDA都会设置一个内部
IDC状态变量,指出返回的最后一个交叉引用的类型。如果需要知道你收到的交叉引用的类型,那么在调用其他交叉引用查询函数之前，必须调用XrefType函数。</p>
<h1 id="数据交叉引用">数据交叉引用</h1>
<p>访问数据交叉引用信息的函数与访问代码交叉引用信息的函数非常类似。这些函数如下所示。</p>
<h3 id="dfirst">Dfirst</h3>
<p>long Dfirst(long from)，</p>
<p>返回给定地址引用一个数据值的第–个位置。</p>
<p>如果给定地址没有引用其他地址，则返回BADADDR ( -1 )。</p>
<h3 id="dnext">Dnext</h3>
<p>long Dnext(1ong from，long current)</p>
<p>如果current已经在前–次调用Dfirst或Dnext时返回，则返回给定地址( from
)</p>
<p>向其引用一个数据值的下一个位置。</p>
<p>如果没有其他交叉引用存在，则返回BADADDR。</p>
<h3 id="xreftype-1">XrefType()</h3>
<p>long XrefType()，返回一个常量，说明某个交叉引用查询函数（如
Dfirst)返回的最后一个交叉引用的类型。</p>
<p>对于数据交叉引用，这些常量包括dr_0(提供的偏移量)、dr_w(数据写人）和dr_R（数据读取)</p>
<h3 id="dfirstb">DfirstB</h3>
<p>long DfirstB(1ong to)</p>
<p>返回将给定地址作为数据引用的第一个位置。</p>
<p>如果不存在引用给定地址的交叉引用，则返回BADADDR ( -1 )</p>
<h3 id="dnextb">DnextB</h3>
<p>long DnextB(long to，1ong current)，如果currnet
已经在前一次调用DfristB或DnextB时返回，则返回将给定地址(
to)作为数据引用的下一次位置。如果没有其他对给定地址的交叉引用存在，则返回BADADDR。和代码交叉引用一样，如果需要知道你收到的交叉引用的类型，那么在调用另一个交叉引用查询函数之前，必须调用XrefType函数</p>
<h1 id="反汇编提取">反汇编提取</h1>
<p>许多时候，我们需要从反汇编代码清单的反汇编行中提取出文本或文本的某个部分。下面的函数可用于访问反汇编行的各种组件</p>
<h2 id="getdisasm">GetDisasm</h2>
<p>string GetDisasm(long
addr)，返回给定地址的反汇编文本。返回的文本包括任何注释，但不包括地址信息</p>
<p>返回该地址的反汇编指令</p>
<pre><code>#include &lt;idc.idc&gt;

static main()
{
    auto currAddr=0;
    auto op =&quot; &quot;;
    currAddr    = ScreenEA();
    op=GetDisasm(currAddr);
    Message(&quot;%s\n&quot;,op);
}</code></pre>
<p>输出</p>
<p><code>mov     edx, dword_445BD8</code></p>
<p>注意返回的字符串,mov和edx之间是4个空格</p>
<h2 id="getmnem">GetMnem</h2>
<p>string GetMnem( auto addr)</p>
<p>返回位于给定地址的汇编指令,比如返回”call”,“jmp”</p>
<p>如果该地址没有指令与之匹配就返回” ”</p>
<h2 id="getopnd">GetOpnd</h2>
<p>string GetOpnd(long addr. long opnum)，</p>
<p>返回指定地址汇编指令的的操作数</p>
<p>IDA以0为起始编号，从左向右对操作数编号。</p>
<h2 id="getoptype">GetOpType</h2>
<p>long GetOpType(long addr.long
opnum)，返回一个整数，指出给定地址的给定操作数的类型。请参考GetOpType的
IDC文档，了解操作数类型代码。</p>
<h2 id="getoperandvalue">GetOperandValue</h2>
<p>long GetOperandValue(long addr. long
opnum)，返回与给定地址的给定操作数有关的整数值。返回值的性质取决于GetOpType指定的给定操作数的类型。15.5
IDC脚本示例211string CommentEx(long addr. long
type)，返回给定地址处的注释文本。如果type为0,则返回常规注释的文本;如果type为1，则返回可重复注释的文本。如果给定地址处没有注释,则返回一个空字符串。</p>
<h2 id="itemsize">ItemSize</h2>
<p>返回汇编指令的长度</p>
<pre><code>ItemSize(给定地址)</code></pre>
<pre><code>.text:00000000004018B6 8B 04 25 54 30 60 00          mov     eax, ds:zero2</code></pre>
<p>如果addr是00000000004018B6,则函数返回7</p>
<p>如果addr是00000000004018B7,则函数返回6</p>
<p>…以此类推</p>
<h2 id="getregvaluerip">GetRegValue(“RIP”)</h2>
<p>GetRegValue(“RIP”)</p>
<p>就这样就可以获取某个寄存器的值</p>
<h2 id="get_func_name">get_func_name</h2>
<p>获取对应地址所在函数的名字</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> funcName <span class="op">=</span> get_func_name<span class="op">(</span>start_func_addr<span class="op">);</span></span></code></pre></div>
<h1 id="misc-func">misc-func</h1>
<p>MinEA() MaxEA() 获取当前idb 的最小地址 和 最大地址</p>
<p>ScreenEA() 获取当前光标所在行的地址, 返回一个 int 类型</p>
<p>SegName(ea) ea是一个变量存储当前地址, 这个api
是获取当前地址所在的段</p>
<p>GetDisasm(ea) 获取当前地址的反汇编代码</p>
<p>GetMnem(ea) 获取当前地址的操作码</p>
<p>GetOpnd(ea,0) 获取当前地址的操作数,第二个参数表示哪一个操作数</p>
<p>SegStart(ea) 获取当前地址所在段的起始地址</p>
<p>SegEnd(ea) 获取当前地址的段尾地址</p>
<p>NextSeg(ea) 获取下一个段的起始地址</p>
<p>idautils.Segments() 返回一个可迭代的对象数组</p>
<p>GetFunctionName(func) 通过地址,获取函数的名称</p>
<p>idautils.Functions() 返回一个可迭代的函数首地址数组,</p>
<p>idaapi.get_func(ea) 获取当前地址的函数首地址和尾地址</p>
<p>NextFunction(ea)
获取下一个函数地址,ea的值可能在函数里面,也可能在函数外面,但是会返回下一个函数的首地址</p>
<p>PrevFunction(ea) 获取前一个函数地址</p>
<p>GetFunctionAttr(ea,FUNCATTR_START) 获取一个函数的边界地址</p>
<p>GetDunctionAttr(ea,FUNCATTR_END) 获取一个函数的边界地址</p>
<p>NextHead</p>
<pre><code>auto NextHead(auto 当前地址,auto 结尾地址)
//head = NextHead(startOEP, End_FUnc);
//head = NextHead(0x00000000, 0xFFFFFFFF);</code></pre>
<p>获取一个当前指令的下一个指令的地址,遍历结束返回-1</p>
<p>函数的不足是:</p>
<p>如果遇到花指令,比如</p>
<pre><code>A1AA F9                                                                       stc
CAT1:0040A1AB 72 03                                                           jb      short loc_40A1B0
CAT1:0040A1AD                                                                 db      64h
CAT1:0040A1AD 64 E3 8F                                                        jecxz   short loc_40A13F</code></pre>
<p>他是不会返回db 64h的地址的</p>
<p>SetColor</p>
<p>SetColor(auto 地址, CIC_ITEM, 16进制颜色值);</p>
<p>get_idb_path()[0:-4]</p>
<pre><code>#include &lt;idc.idc&gt;
static main(void)
{
    Message(&quot;%s\n&quot;,get_idb_path()[0:-4]);
}
//输出当前文件所在目录,具体是当前idb文件所在目录</code></pre>
<h1 id="附录">附录</h1>
<p>一个很好的IDA资源插件介绍,没去下载应用</p>
<p><a
href="https://www.dazhuanlan.com/sisiyoki/topics/1183415">https://www.dazhuanlan.com/sisiyoki/topics/1183415</a></p>
            </div>
    </div>
  </div>
  <script src="https://vjs.zencdn.net/5.4.4/video.js"></script>

</body>
</html>
