<!doctype html>
<html >
<head>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!--[if lt IE 9]>
                <script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
        <![endif]-->
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />

    <!-- <link rel="stylesheet" type="text/css" href="template.css" /> -->
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/template.css" />

    <link href="https://vjs.zencdn.net/5.4.4/video-js.css" rel="stylesheet" />

    <script src="https://code.jquery.com/jquery-2.2.1.min.js"></script>
    <!-- <script type='text/javascript' src='menu/js/jquery.cookie.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.hoverIntent.minified.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.dcjqaccordion.2.7.min.js'></script> -->

    <!-- <link href="menu/css/skins/blue.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/graphite.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/grey.css" rel="stylesheet" type="text/css" /> -->
  
    <!-- <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
        
  
    <!-- <script src="script.js"></script> -->
  
    <!-- <script src="jquery.sticky-kit.js "></script> -->
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.cookie.js'></script>
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.hoverIntent.minified.js'></script>
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.dcjqaccordion.2.7.min.js'></script>

    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/blue.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/graphite.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/grey.css" rel="stylesheet" type="text/css" />
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
    <script src="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/script.js"></script>
  
    <script src="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/jquery.sticky-kit.js"></script>
    <meta name="generator" content="pandoc" />
  <title>wiki-Reverse-winRe-shellcode-核心API加载</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>

    
    <div class="navbar navbar-static-top">
    <div class="navbar-inner">
      <div class="container">
        <span class="doc-title">wiki-Reverse-winRe-shellcode-核心API加载</span>
        <ul class="nav pull-right doc-info">
                            </ul>
      </div>
    </div>
  </div>
    <div class="container">
    <div class="row">
            <div id="TOC" class="span3">
        <div class="well toc">

        <ul>
        <li><a href="#x86之shellcode如何获取getprocaddress和loadlibrary"
        id="toc-x86之shellcode如何获取getprocaddress和loadlibrary">x86之shellcode如何获取GetProcAddress和LoadLibrary</a></li>
        <li><a href="#步骤如下" id="toc-步骤如下">步骤如下</a>
        <ul>
        <li><a href="#首先获取kernel32.dll的基地址"
        id="toc-首先获取kernel32.dll的基地址">首先获取kernel32.dll的基地址</a></li>
        <li><a href="#然后找到kernel32.dll的导出表"
        id="toc-然后找到kernel32.dll的导出表">然后找到kernel32.dll的导出表</a></li>
        <li><a href="#然后遍历导出表信息获取getprocaddress"
        id="toc-然后遍历导出表信息获取getprocaddress">然后遍历导出表信息,获取GetProcAddress</a></li>
        <li><a href="#通过getprocaddress获取loadlibrary"
        id="toc-通过getprocaddress获取loadlibrary">通过GetProcAddress获取LoadLibrary</a></li>
        </ul></li>
        <li><a href="#总的如下" id="toc-总的如下">总的如下</a></li>
        <li><a href="#关于hash-函数名的算法"
        id="toc-关于hash-函数名的算法">关于hash 函数名的算法</a></li>
        </ul>

        </div>
      </div>
            <div class="span9">

      
      <h1
id="x86之shellcode如何获取getprocaddress和loadlibrary">x86之shellcode如何获取GetProcAddress和LoadLibrary</h1>
<h1 id="步骤如下">步骤如下</h1>
<p>下面4个步骤的寄存器是有关联的</p>
<p>环境有关系</p>
<h2 id="首先获取kernel32.dll的基地址">首先获取kernel32.dll的基地址</h2>
<pre class="assembly"><code>xor ecx, ecx;
mov eax, fs: [ecx + 0x30] ;//获取PEB
mov eax, [eax + 0xc];   // 获取LDR
mov esi, [eax + 0x14]; //获取 InMemOrder,然后已经指向了当前进程
lodsd;  //指向ntdll
xchg eax, esi;   //数据交换
lodsd; //指向Kernel32.dll
mov ebx, [eax + 0x10]; //获取Base address</code></pre>
<p>这里是简单的获取kernel32.dll基地址</p>
<p>获取kernel32.dll基地址方法很多,,,挑一个喜欢的</p>
<h2 id="然后找到kernel32.dll的导出表">然后找到kernel32.dll的导出表</h2>
<pre class="assembly"><code>mov edx, [ebx + 0x3c]; //获取偏移
add edx, ebx; //来到PE头
mov edx, [edx + 0x78]; //获取导出表
add edx, ebx; 
mov esi, [edx + 0x20]; //获取 AddressOfNames
add esi, ebx; </code></pre>
<p>这里是通过PE结构,,,然后找到导出表</p>
<p>导出表结构如下</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> _IMAGE_EXPORT_DIRECTORY</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    DWORD   Characteristics<span class="op">;</span>        <span class="co">//+0 未使用 导出表的特征标志，一般为0 </span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    DWORD   TimeDateStamp<span class="op">;</span>          <span class="co">//+4 时间戳 导出表的创建时间戳。</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    WORD    MajorVersion<span class="op">;</span>           <span class="co">//+8h 未使用 导出表的主版本号</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    WORD    MinorVersion<span class="op">;</span>           <span class="co">//+10 未使用 导出表的次版本号。</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    DWORD   Name<span class="op">;</span>                   <span class="co">//+12 字符串指针 dll的名字</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    DWORD   Base<span class="op">;</span>                   <span class="co">//+16 基址编号 导出表中所有函数的序号起始值，默认为1</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    DWORD   NumberOfFunctions<span class="op">;</span>      <span class="co">//+20 导出表中的导出函数数量,其中是有空函数的</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    DWORD   NumberOfNames<span class="op">;</span>          <span class="co">//+24 导出表中有字符串名称的导出函数数量</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    DWORD   AddressOfFunctions<span class="op">;</span>     <span class="co">//+28  dword数组, 实际函数的RvA数组 导出表中所有导出函数</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    DWORD   AddressOfNames<span class="op">;</span>         <span class="co">//+32 dword数组 导出表中所有有名称的导出函数的名称</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    DWORD   AddressOfNameOrdinals<span class="op">;</span>  <span class="co">//+36 word数组  导出表中所有有名称的导出函数序号,成员是(序号-BASE)的序列</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> IMAGE_EXPORT_DIRECTORY<span class="op">,</span> <span class="op">*</span>PIMAGE_EXPORT_DIRECTORY<span class="op">;</span></span></code></pre></div>
<h2
id="然后遍历导出表信息获取getprocaddress">然后遍历导出表信息,获取GetProcAddress</h2>
<pre class="assembly"><code>    xor ecx, ecx;
Get_Function:
    ; //ebx 是基地址
    ; //esi 是AddressOfNames
    ; //ecx 是遍历的次数
    ; //edx是导出表结构体的起始地址
    inc ecx; //次数增加
    lodsd; //mov eax,[esi]
    add eax, ebx; //获取真实的地址
    cmp dword ptr[eax], 0x50746547; 
    jnz Get_Function;
    cmp dword ptr[eax + 0x4], 0x41636f72; rocA
    jnz Get_Function;
    cmp dword ptr[eax + 0x8], 0x65726464; ddre
    jnz Get_Function;

    //找到了
    mov esi, [edx + 0x24]; //获取AddressOfNameOrdinals
    add esi, ebx; 

    dec ecx
    mov cx, [esi + ecx * 2];//基于word的数组
    mov esi, [edx + 0x1c]; //获取 AddressOfFunctions
    add esi, ebx; 
    mov edx, [esi + ecx * 4]; 
    add edx, ebx; //最后得到真实的地址</code></pre>
<p>这是一个简单的遍历<code>AddressOfNameOrdinals,AddressOfFunctions,AddressOfNames</code></p>
<p>其中字符串的比较我之前没有遇到过</p>
<pre class="assembly"><code>cmp dword ptr[eax], 0x50746547; 
jnz Get_Function;
cmp dword ptr[eax + 0x4], 0x41636f72; rocA
jnz Get_Function;
cmp dword ptr[eax + 0x8], 0x65726464; ddre</code></pre>
<p>他不是利用全局的字符串</p>
<p>而是通过4字节写到机器码中,
<code>0x50746547,0x41636f72,0x65726464</code></p>
<h2
id="通过getprocaddress获取loadlibrary">通过GetProcAddress获取LoadLibrary</h2>
<pre class="assembly"><code>xor ecx, ecx; ECX = 0
push ebx; Kernel32 base address
push edx; GetProcAddress

push ecx; 0
push 0x41797261; aryA
push 0x7262694c; Libr
push 0x64616f4c; Load

push esp; &quot;LoadLibrary&quot;
push ebx; Kernel32 base address
call edx; //获取LoadLibrary
add esp, 0xc;</code></pre>
<h1 id="总的如下">总的如下</h1>
<pre class="assembly"><code>    _asm
    {
        xor ecx, ecx;
        mov eax, fs: [ecx + 0x30] ;//获取PEB
        mov eax, [eax + 0xc];// 获取LDR
        mov esi, [eax + 0x14]; //获取 InMemOrder,然后已经指向了当前进程
        lodsd;  //指向ntdll
        xchg eax, esi;   //数据交换
        lodsd; //指向Kernel32.dll
        mov ebx, [eax + 0x10]; //获取Base address
            
        mov edx, [ebx + 0x3c]; //获取偏移
        add edx, ebx; //来到PE头
        mov edx, [edx + 0x78]; //获取导出表
        add edx, ebx; 
        mov esi, [edx + 0x20]; //获取 AddressOfNames
        add esi, ebx; 

        xor ecx, ecx;
    Get_Function:
        ; //ebx 是基地址
        ; //esi 是AddressOfNames
        ; //ecx 是遍历的次数
        ; //edx是导出表结构体的起始地址
        inc ecx; //次数增加
        lodsd; //mov eax,[esi]
        add eax, ebx; //获取真实的地址
        cmp dword ptr[eax], 0x50746547; 
        jnz Get_Function;
        cmp dword ptr[eax + 0x4], 0x41636f72; rocA
        jnz Get_Function;
        cmp dword ptr[eax + 0x8], 0x65726464; ddre
        jnz Get_Function;

        //找到了
        mov esi, [edx + 0x24]; //获取AddressOfNameOrdinals
        add esi, ebx; 
        
        dec ecx
        mov cx, [esi + ecx * 2];//基于word的数组
        mov esi, [edx + 0x1c]; //获取 AddressOfFunctions
        add esi, ebx; 
        mov edx, [esi + ecx * 4]; 
        add edx, ebx; //最后得到真实的地址

        xor ecx, ecx; ECX = 0
        push ebx; Kernel32 base address
        push edx; GetProcAddress

        push ecx; 0
        push 0x41797261; aryA
        push 0x7262694c; Libr
        push 0x64616f4c; Load

        push esp; &quot;LoadLibrary&quot;
        push ebx; Kernel32 base address
        call edx; //获取LoadLibrary
        add esp, 0xc;
        
        //一些自定义的代码
    }</code></pre>
<p>另外一个大佬的版本,使用nasm进行一个编译</p>
<pre class="assembly"><code>; exec_calc.asm
global Start
section .data
section .text
Start:
    push ebp
    mov ebp, esp
    sub esp, 0x12
    call GetKernel32BaseAddr
    mov dword [ebp-4],eax ; Kernel32.dll Base Addr
    push eax
    call GetProcAddrFuncAddr
    mov dword [ebp-8],eax ; GetProcAddress
    push 0x00636578 ; xec,0x00
    push 0x456e6957 ; WinE
    push esp
    push dword [ebp-4] ; [ebp-4] -&gt; Kernel32.DLL Base Addr
    call dword [ebp-8] ; [ebp-8] -&gt; GetProcAddress Addr
    push 0                ; WinExec uCmdShow
    push 0x6578652e       ; exe. : 6578652e
    push 0x636c6163       ; clac : 636c6163
    push esp
    call eax
    nop
    nop
    add esp,0x12
    mov esp,ebp
    pop ebp
    ret
GetKernel32BaseAddr:
    push ebp
    mov ebp,esp
    sub esp,0x40
    xor ebx, ebx            ; EBX = 0x00000000
    mov ebx, [fs:ebx+0x30]  ; EBX = Address_of_PEB
    mov ebx, [ebx+0xC]      ; EBX = Address_of_LDR
    mov ebx, [ebx+0x1C]     ; EBX = 1st entry in InitOrderModuleList / ntdll.dll
    mov ebx, [ebx]          ; EBX = 2nd entry in InitOrderModuleList / kernelbase.dll
    mov ebx, [ebx]          ; EBX = 3rd entry in InitOrderModuleList / kernel32.dll
    mov eax, [ebx+0x8]      ; EAX = &amp;kernel32.dll / Address of kernel32.dll
    add esp,0x40
    mov esp,ebp
    pop ebp
    ret
GetProcAddrFuncAddr:
    push ebp
    mov ebp,esp
    sub esp,0x40
    xor ecx, ecx
    mov ebx, [ebp + 8] ; EBX = Base address
    mov edx, [ebx + 0x3c]    ; EDX = DOS-&gt;e_lfanew
    add edx, ebx             ; EDX = PE Header
    mov edx, [edx + 0x78]    ; EDX =  export table
    add edx, ebx             ; EDX = Export table
    mov esi, [edx + 0x20]    ; ESI =  namestable
    add esi, ebx             ; ESI = Names table
    xor ecx, ecx             ; EXC = 0
    Get_Function:
            inc ecx                  ; Increment the ordinal
            lodsd                    ; Get name
            add eax, ebx             ; Get function name
            cmp dword [eax], 50746547h       ; GetP
            jnz Get_Function
            cmp dword [eax + 0x04], 41636f72h ; rocA
            jnz Get_Function
            cmp dword [eax + 0x08], 65726464h ; ddre
            jnz Get_Function
    mov esi, [edx + 0x24]                ; ESI =  ordinals
    add esi, ebx                         ; ESI = Ordinals table
    mov cx, [esi + ecx * 2]              ; Number of function
    dec ecx
    mov esi, [edx + 0x1c]                ;  address table
    add esi, ebx                         ; ESI = Address table
    mov edx, [esi + ecx * 4]             ; EDX = Pointer()
    add edx, ebx                         ; EDX = GetProcAddress
    mov eax,edx
    add esp,0x40
    mov esp,ebp
    pop ebp
    ret
</code></pre>
<h1 id="关于hash-函数名的算法">关于hash 函数名的算法</h1>
<p>其实就是,,我们已经拿到了 GetProcAddress 和 LoadLibrary</p>
<p>当我们去获取一个目标函数的时候 GetProcAddress (xx_base,xx_name)</p>
<p>想这种方式去获取API的话,,,有点赤裸裸的,,,也就是比较暴露目标API的string</p>
<p>于是网上出现了另外一种方法,,,,</p>
<p>假设我们有这么一种hash算法, ROR13</p>
<p>假设我们已经有了目标API的hash是A, 目标dll的hash是B</p>
<p>我们先遍历每一个模块,,,计算他们的ROR13
hash,然后我们提供的hash做一个比较</p>
<p>当我们找到目标DLL后,,,然后遍历他们导出的函数,,计算他们的ROR13,,,,然后我们提供的hash做一个比较</p>
<p>通过这样的方式,,,我们就可以避免提供明文字符串来获取API</p>
<p>当然我还见过一种方式,只提供一个ROR13,,就获取目标API的</p>
<p>也就是遍历已装载dll的所有导出函数,,,然后计算他们dllname和funcname的ROR13哈希,,然后和我们提供的hash做一个人比较</p>
<p>ROR13 hash算法实现</p>
<p>ps: 最好别用这种,,任意被查杀</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>DWORD __stdcall unicode_ror13_hash<span class="op">(</span><span class="dt">const</span> WCHAR <span class="op">*</span>unicode_string<span class="op">)</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    DWORD hash <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(*</span>unicode_string <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        DWORD val <span class="op">=</span> <span class="op">(</span>DWORD<span class="op">)*</span>unicode_string<span class="op">++;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        hash <span class="op">=</span> <span class="op">(</span>hash <span class="op">&gt;&gt;</span> <span class="dv">13</span><span class="op">)</span> <span class="op">|</span> <span class="op">(</span>hash <span class="op">&lt;&lt;</span> <span class="dv">19</span><span class="op">);</span> <span class="co">// ROR 13</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        hash <span class="op">+=</span> val<span class="op">;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hash<span class="op">;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>DWORD __stdcall ror13_hash<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>string<span class="op">)</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    DWORD hash <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(*</span>string<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        DWORD val <span class="op">=</span> <span class="op">(</span>DWORD<span class="op">)</span> <span class="op">*</span>string<span class="op">++;</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        hash <span class="op">=</span> <span class="op">(</span>hash <span class="op">&gt;&gt;</span> <span class="dv">13</span><span class="op">)|(</span>hash <span class="op">&lt;&lt;</span> <span class="dv">19</span><span class="op">);</span>  <span class="co">// ROR 13</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        hash <span class="op">+=</span> val<span class="op">;</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hash<span class="op">;</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>我们提供的dll好像一般都是英文名字,,,好像也有其它乱七八糟的字符,,但是函数的名字一定是中文</p>
            </div>
    </div>
  </div>
  <script src="https://vjs.zencdn.net/5.4.4/video.js"></script>

</body>
</html>
