---
title: wiki-Reverse-elfRe-C语言-基础C
---


# so文件



像window调用库文件一样，在`linux`下，也有相应的API因为加载库文件而存在。它们主要是以下几个函数：

| 函数名  | 功能描述                                                     |
| :------ | :----------------------------------------------------------- |
| dlopen  | 打开对象文件，使其可被程序访问                               |
| dlsym   | 获取执行了 `dlopen` 函数的对象文件中的函数的地址             |
| dlerror | 该函数没有参数，它会在发生前面的错误时返回一个字符串，同时将其从内存中清空； 在没有错误发生时返回 NULL， |
| dlclose | 关闭目标文件。如果无需再调用共享对象的话，应用程序可以调用该方法来通知操作系统不再需要句柄和对象引用了。它完全是按引用来计数的，所以同一个共享对象的多个用户相互间不会发生冲突（只要还有一个用户在使用它，它就会在内存中）。任何通过已关闭的对象的 `dlsym` 解析的符号都将不再可用 |



 实例



首先，您需要包含必要的头文件：

```
#include <dlfcn.h>	
```

使用`dlopen`函数来加载共享库，类似于`LoadLibraryA`的功能。

```
void* handle = dlopen("libmylibrary.so", RTLD_LAZY);
```



动态库加载成功后,就可以获取相关函数的地址了

可以使用`dlsym`函数来获取共享库中导出函数的指针

```
void (*myFunction)() = dlsym(handle, "functionName");	
```

最后dll的释放

```
dlclose(handle);
```



关于`dlopen`

其中，`filename` 参数指定共享库文件名，`flag` 参数是打开模式，有如下几种取值：

- `RTLD_NOW`：在 `dlopen` 调用时，立即解析符号并绑定至全局符号表中。
- `RTLD_LAZY`：只在符号被使用时才进行解析和绑定操作。
- `RTLD_GLOBAL`：将共享库中定义的符号添加到全局符号表中，使得其他共享库也可以访问该符号。
- `RTLD_LOCAL`：仅将共享库中定义的符号添加到局部符号表中，使得对该共享库的后续加载操作也会使用局部符号表中的符号。



如果要获取 已经加载的模块

```
dladdr
```


