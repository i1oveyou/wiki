<!doctype html>
<html >
<head>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!--[if lt IE 9]>
                <script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
        <![endif]-->
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />

    <!-- <link rel="stylesheet" type="text/css" href="template.css" /> -->
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/template.css" />

    <link href="https://vjs.zencdn.net/5.4.4/video-js.css" rel="stylesheet" />

    <script src="https://code.jquery.com/jquery-2.2.1.min.js"></script>
    <!-- <script type='text/javascript' src='menu/js/jquery.cookie.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.hoverIntent.minified.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.dcjqaccordion.2.7.min.js'></script> -->

    <!-- <link href="menu/css/skins/blue.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/graphite.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/grey.css" rel="stylesheet" type="text/css" /> -->
  
    <!-- <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
        
  
    <!-- <script src="script.js"></script> -->
  
    <!-- <script src="jquery.sticky-kit.js "></script> -->
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.cookie.js'></script>
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.hoverIntent.minified.js'></script>
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.dcjqaccordion.2.7.min.js'></script>

    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/blue.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/graphite.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/grey.css" rel="stylesheet" type="text/css" />
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
    <script src="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/script.js"></script>
  
    <script src="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/jquery.sticky-kit.js"></script>
    <meta name="generator" content="pandoc" />
  <title>wiki-Reverse-winRe-shellcode-howtogetEIP</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>

    
    <div class="navbar navbar-static-top">
    <div class="navbar-inner">
      <div class="container">
        <span class="doc-title">wiki-Reverse-winRe-shellcode-howtogetEIP</span>
        <ul class="nav pull-right doc-info">
                            </ul>
      </div>
    </div>
  </div>
    <div class="container">
    <div class="row">
            <div id="TOC" class="span3">
        <div class="well toc">

        <ul>
        <li><a href="#x86之shellcode如何获取自己的eip"
        id="toc-x86之shellcode如何获取自己的eip">x86之shellcode如何获取自己的eip</a></li>
        <li><a href="#为什么会提出这个问题呢"
        id="toc-为什么会提出这个问题呢">为什么会提出这个问题呢</a></li>
        <li><a href="#方法" id="toc-方法">方法</a>
        <ul>
        <li><a href="#方法一-call的入栈"
        id="toc-方法一-call的入栈">方法一: call的入栈</a></li>
        <li><a href="#方法二-call-重构"
        id="toc-方法二-call-重构">方法二: call 重构</a></li>
        <li><a href="#方法三-浮点运指令特性"
        id="toc-方法三-浮点运指令特性">方法三: 浮点运指令特性</a></li>
        <li><a href="#其它方法" id="toc-其它方法">其它方法</a></li>
        </ul></li>
        <li><a href="#后期" id="toc-后期">后期</a></li>
        </ul>

        </div>
      </div>
            <div class="span9">

      
      <h1
id="x86之shellcode如何获取自己的eip">x86之shellcode如何获取自己的eip</h1>
<h1 id="为什么会提出这个问题呢">为什么会提出这个问题呢</h1>
<p>一些shellcode在对自己的资源重定位上,,,会用到自我的eip定位</p>
<p>比如或者一些xxxx,如全局的变量,,如字符串,,,如函数,,,</p>
<p>这些都需要通过定位来实现,,,于是就引出如何获取eip这个问题了</p>
<h1 id="方法">方法</h1>
<h2 id="方法一-call的入栈">方法一: call的入栈</h2>
<p>就是把返回地址入栈</p>
<p>返回地址就是一个很真实的东西</p>
<p>常见的模型如下</p>
<pre class="assembly"><code>call tag;
tag:
pop eax;</code></pre>
<p>这样就获取了<code>pop eax</code>汇编所在的eip地址了</p>
<p>然后通过后期的一些处理,,,就可以定位到自己的字符串</p>
<p>举一个例子</p>
<figure>
<img src="./img/image-20230722163015295.png"
alt="image-20230722163015295" />
<figcaption aria-hidden="true">image-20230722163015295</figcaption>
</figure>
<p>比如我们已知x1的地址,,如何获取y1的地址</p>
<p>那就是x1的真实地址+一个相对偏移,,然后就可以定位到y1</p>
<p>这个相对偏移,,比如是(y1地址-x1地址)</p>
<p>无论x1地址怎么变化,,,我们只要拿着x1的真实地址,,然后x1+一个偏移,,就可以获取y1的真实地址</p>
<p>所以,,大概就是这么一个道理,,,如果读者读不懂,,可以多看几遍</p>
<p>于是见一下代码</p>
<p>ps: 这个例子不太妥当,,,但是也想不到其它例子了</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include</span><span class="im">&lt;Windows.h&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> lpfuncAddr<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;you got me!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    DWORD<span class="op">*</span> lp_apiAddr<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    __asm <span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        push eax<span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        push ebx<span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        push ecx<span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    label_code<span class="op">:</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        call label_reloc<span class="op">;</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    label_reloc<span class="op">:</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        pop ebx<span class="op">;</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">//重定位lpfuncAddr;</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        lea eax<span class="op">,</span> lpfuncAddr<span class="op">;</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        sub eax<span class="op">,</span> label_reloc<span class="op">;</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        add eax<span class="op">,</span> ebx<span class="op">;</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        lea ecx<span class="op">,</span> lp_apiAddr<span class="op">;</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        mov<span class="op">[</span>ecx<span class="op">],</span> eax<span class="op">;</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>        call eax<span class="op">;</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        pop ecx<span class="op">;</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>        pop ebx<span class="op">;</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>        pop eax<span class="op">;</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>比如我们获取函数<code>lpfuncAddr</code>的地址,,存入到<code>lp_apiAddr</code>,并调用函数</p>
<p>ebx就是一个真实地址,,,然后<code>label_reloc</code>也是<code>pop ebx;</code>的一个原始地址,<code>label_reloc</code>也是一个原始地址</p>
<p>在汇编里面,下面这2巨汇编涉及的地址会被写死的</p>
<pre class="assembly"><code>        //重定位lpfuncAddr;
        lea eax, lpfuncAddr;
        sub eax, label_reloc;</code></pre>
<figure>
<img src="./img/image-20231209213042743.png"
alt="image-20231209213042743" />
<figcaption aria-hidden="true">image-20231209213042743</figcaption>
</figure>
<p>然后我们尝试调试一下</p>
<figure>
<img src="./img/image-20231209213251723.png"
alt="image-20231209213251723" />
<figcaption aria-hidden="true">image-20231209213251723</figcaption>
</figure>
<p>可以看到真实的基地址是<code>00600000</code>,原始的是<code>00400000</code></p>
<p>然后通过定位好,,可以看到,,,eax已经获取了目标函数了</p>
<p>为什么说,,这个例子举得不好,,,</p>
<p>因为exe会重定位的,,,就针对本代码而言</p>
<figure>
<img src="./img/image-20231209213608784.png"
alt="image-20231209213608784" />
<figcaption aria-hidden="true">image-20231209213608784</figcaption>
</figure>
<p>只不过,,之前的</p>
<figure>
<img src="./img/image-20231209213624093.png"
alt="image-20231209213624093" />
<figcaption aria-hidden="true">image-20231209213624093</figcaption>
</figure>
<p>是被我手动修改了罢了,,,但也不影响</p>
<h2 id="方法二-call-重构">方法二: call 重构</h2>
<p>call类型来实现代码重构,,,</p>
<p>那是什么意思???</p>
<figure>
<img src="./img/image-20231209221233614.png"
alt="image-20231209221233614" />
<figcaption aria-hidden="true">image-20231209221233614</figcaption>
</figure>
<p>可以看到<code>call    near ptr loc_9F18D8+4</code></p>
<p>call的地址是0F18DC,然后返回地址<code>009F18DD</code>会入栈</p>
<p>然后call之后,,第一句执行的却是 <code>FFC3</code></p>
<p>FFC3是inc ebx,,,虽然这个C3可以自定义,,比如inc eax是FFC2</p>
<p>所以FFC3其实就是一个代码重构,,拿着<code>E8 FF FF FF FF</code>的FF和C3一起重构为inc
ebx</p>
<p>然后再来一个0x5B,也就是pop
ebx,,把栈的返回值给拿出来,,,一样的实现了方法一的效果</p>
<p>只不过会比方法1多消耗一个字节,,,方法1用6字节,,,方法2用7字节,,,但是干扰效果比方法1好</p>
<figure>
<img src="./img/image-20231209222407182.png"
alt="image-20231209222407182" />
<figcaption aria-hidden="true">image-20231209222407182</figcaption>
</figure>
<p>例子如下</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include</span><span class="im">&lt;Windows.h&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> lpfuncAddr<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;you got me!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    DWORD<span class="op">*</span> lp_apiAddr<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    __asm <span class="op">{</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        push eax<span class="op">;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        push ebx<span class="op">;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        push ecx<span class="op">;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        _emit <span class="bn">0xE8</span><span class="op">;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        _emit <span class="bn">0xFF</span><span class="op">;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        _emit <span class="bn">0xFF</span><span class="op">;</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        _emit <span class="bn">0xFF</span><span class="op">;</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        _emit <span class="bn">0xFF</span><span class="op">;</span> <span class="co">//上面完整的形成了一条汇编指令,,然后label_relo就是要入栈的地址</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    label_reloc<span class="op">:</span> </span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        _emit <span class="bn">0xC3</span><span class="op">;</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        _emit <span class="bn">0x5B</span><span class="op">;</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">//重定位lpfuncAddr;</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        lea eax<span class="op">,</span> lpfuncAddr<span class="op">;</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        sub eax<span class="op">,</span> label_reloc<span class="op">;</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        add eax<span class="op">,</span> ebx<span class="op">;</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>        lea ecx<span class="op">,</span> lp_apiAddr<span class="op">;</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        mov<span class="op">[</span>ecx<span class="op">],</span> eax<span class="op">;</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>        call eax<span class="op">;</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>        pop ecx<span class="op">;</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>        pop ebx<span class="op">;</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>        pop eax<span class="op">;</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>为什么我们在<code>_emit 0xFF;</code>后写<code>label_reloc:</code>,而不是其它字节之后呢???</p>
<pre class="assembly"><code>        _emit 0xE8;
        _emit 0xFF;
        _emit 0xFF;
        _emit 0xFF;
        _emit 0xFF; //上面完整的形成了一条汇编指令,,然后label_relo就是要入栈的地址
    label_reloc: </code></pre>
<p>这要追溯到方法1的原理了</p>
<p><img src="./img/image-20230722163015295.png" /></p>
<p>ebx是call入栈的地址,,,也是x1的真实地址,,</p>
<p>我们要保证栈中的地址和x1地址是有关系的,,,,x1是原始的,,栈的是真实的</p>
<p>这就是为什么我们要在xxx后面写label_reloc地址了</p>
<pre class="assembly"><code>        _emit 0xE8;
        _emit 0xFF;
        _emit 0xFF;
        _emit 0xFF;
        _emit 0xFF; //上面完整的形成了一条汇编指令,,然后label_relo就是要入栈的地址
    label_reloc: </code></pre>
<h2 id="方法三-浮点运指令特性">方法三: 浮点运指令特性</h2>
<p>什么特性呢?</p>
<p>在一个浮点数指令执行后,,,,他的执行地址会被特殊的保存起来</p>
<p>然后我们可以把保存的地址pop导出到栈中,然后读取出来</p>
<p>案例1</p>
<pre class="assembly"><code>.text:00A65084 D9 EE                         fldz
.text:00A65086 D9 74 24 F4                   fnstenv byte ptr [esp-12]
.text:00A6508A 5B                            pop     ebx</code></pre>
<figure>
<img src="./img/image-20231209223211445.png"
alt="image-20231209223211445" />
<figcaption aria-hidden="true">image-20231209223211445</figcaption>
</figure>
<p>案例2</p>
<pre class="assembly"><code>debug043:00E00000 DA C5                         fcmovb  st, st(5)
debug043:00E00002 B8 5B 43 B1 DA                mov     eax, 0DAB1435Bh
debug043:00E00007 D9 74 24 F4                   fnstenv byte ptr [esp-12]
debug043:00E0000B 5D                            pop     ebp</code></pre>
<p>案例3</p>
<pre class="assembly"><code>.data:0041A005 DA C9                         fcmove  st, st(1)
.data:0041A007 D9 74 24 F4                   fnstenv byte ptr [esp-12]
.data:0041A00B 5F                            pop     edi;edi直接获取0041A005</code></pre>
<p>案例4</p>
<pre class="assembly"><code>.data:0041A01B fcmovbe st, st(2)
.data:0041A01D fnstenv byte ptr [esp-12]
.data:0041A021 pop     eax;eax直接获取0041A01</code></pre>
<p>案例5</p>
<pre class="assembly"><code>.data:0041A036 fldpi
.data:0041A038 mov     ebx, 0F575EA6Bh
.data:0041A03D
.data:0041A03D loc_41A03D 
.data:0041A03D  fnstenv byte ptr [esp-12]
.data:0041A041 pop     ebp ;ebp直接获取0041A036 </code></pre>
<p>总结规律</p>
<p><code>fnstenv byte ptr [esp-12]</code>
会把最近最靠近的那个浮点数操作指令的地址入栈</p>
<p>然后pop 出来就是那个地址</p>
<p>所以常见浮点数操作</p>
<pre class="assembly"><code>D9 EE                         fldz
D9 EB                         fldpi
D9 C2                         fld     st(2)
DD C6                         ffree   st(6)
D9 CE                         fxch    st(6)
D9 E9                         fldl2t
DB D0                         fcmovnbe st, st
DA C9                         fcmove  st, st(1)
DA D2                         fcmovbe st, st(2)
DB C3                         fcmovnb st, st(3)
DA C5                         fcmovb  st, st(5)
DA D6                         fcmovbe st, st(6)
DB CF                         fcmovne st, st(7)</code></pre>
<h2 id="其它方法">其它方法</h2>
<p>中断: 说用int 2Eh 或者 int 2Ch 可以把下一条地址入ebx,没有实验成功</p>
<p>异常: 通过异常,可以记录异常发生的位置eip</p>
<p>但是没有超过过</p>
<h1 id="后期">后期</h1>
<p>关于x64如何获取自己的RIP</p>
            </div>
    </div>
  </div>
  <script src="https://vjs.zencdn.net/5.4.4/video.js"></script>

</body>
</html>
